// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface APIKeyDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface APIKeyDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface ApplicationDefaultConfig {
    /**
     * Indicates whether or not to use HTTP in measurements.
     */
    http: pulumi.Input<boolean>;
    /**
     * Indicates whether or not to use HTTPS in measurements.
     */
    https?: pulumi.Input<boolean>;
    /**
     * - Maximum timeout per job
     * 0, the primary NSONE Global Network. Normally, you should not have to worry about this.
     */
    jobTimeoutMillis?: pulumi.Input<number>;
    /**
     * Maximum timeout per request.
     */
    requestTimeoutMillis?: pulumi.Input<number>;
    /**
     * - Indicates whether or not to skip aggregation for this job's measurements
     */
    staticValues?: pulumi.Input<boolean>;
    /**
     * - Whether to use XMLHttpRequest (XHR) when taking measurements.
     */
    useXhr?: pulumi.Input<boolean>;
}

export interface MonitoringJobRule {
    comparison: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface NotifyListNotification {
    /**
     * Configuration details for the given notifier type.
     */
    config: pulumi.Input<{[key: string]: any}>;
    /**
     * The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
     */
    type: pulumi.Input<string>;
}

export interface PulsarJobBlendMetricWeights {
    timestamp: pulumi.Input<number>;
}

export interface PulsarJobConfig {
    host?: pulumi.Input<string>;
    http?: pulumi.Input<boolean>;
    https?: pulumi.Input<boolean>;
    jobTimeoutMillis?: pulumi.Input<number>;
    requestTimeoutMillis?: pulumi.Input<number>;
    staticValues?: pulumi.Input<boolean>;
    urlPath?: pulumi.Input<string>;
    useXhr?: pulumi.Input<boolean>;
}

export interface PulsarJobWeight {
    defaultValue: pulumi.Input<number>;
    maximize?: pulumi.Input<boolean>;
    name: pulumi.Input<string>;
    weight: pulumi.Input<number>;
}

export interface RecordAnswer {
    /**
     * Space delimited string of RDATA fields dependent on the record type.
     */
    answer?: pulumi.Input<string>;
    meta?: pulumi.Input<{[key: string]: any}>;
    /**
     * The region (Answer Group really) that this answer
     * belongs to. This should be one of the names specified in `regions`. Only a
     * single `region` per answer is currently supported. If you want an answer in
     * multiple regions, duplicating the answer (including metadata) is the correct
     * approach.
     * * ` meta` - (Optional) meta is supported at the `answer` level. Meta
     * is documented below.
     */
    region?: pulumi.Input<string>;
}

export interface RecordFilter {
    /**
     * The filters' configuration. Simple key/value pairs
     * determined by the filter type.
     */
    config?: pulumi.Input<{[key: string]: any}>;
    /**
     * Determines whether the filter is applied in the
     * filter chain.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The type of filter.
     */
    filter: pulumi.Input<string>;
}

export interface RecordRegion {
    meta?: pulumi.Input<{[key: string]: any}>;
    /**
     * Name of the region (or Answer Group).
     */
    name: pulumi.Input<string>;
}

export interface TeamDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface TeamDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface TeamIpWhitelist {
    /**
     * The free form name of the team.
     */
    name: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface UserDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface ZoneSecondary {
    /**
     * IPv4 address of the secondary server.
     */
    ip: pulumi.Input<string>;
    /**
     * - List of network IDs (`int`) for which the zone
     * should be made available. Default is network 0, the primary NSONE Global
     * Network. Normally, you should not have to worry about this.
     */
    networks?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Whether we send `NOTIFY` messages to the secondary host
     * when the zone changes. Default `false`.
     */
    notify?: pulumi.Input<boolean>;
    /**
     * Port of the the secondary server. Default `53`.
     */
    port?: pulumi.Input<number>;
}

