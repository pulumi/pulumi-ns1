// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface APIKeyDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface APIKeyDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface AlertData {
    /**
     * required by the account/usage alerts, with a value between 1 and 100
     */
    alertAtPercent?: pulumi.Input<number>;
}

export interface ApplicationDefaultConfig {
    /**
     * Indicates whether or not to use HTTP in measurements.
     */
    http: pulumi.Input<boolean>;
    /**
     * Indicates whether or not to use HTTPS in measurements.
     */
    https?: pulumi.Input<boolean>;
    /**
     * Maximum timeout per job
     * 0, the primary NSONE Global Network. Normally, you should not have to worry about this.
     */
    jobTimeoutMillis?: pulumi.Input<number>;
    /**
     * Maximum timeout per request.
     */
    requestTimeoutMillis?: pulumi.Input<number>;
    /**
     * Indicates whether or not to skip aggregation for this job's measurements
     */
    staticValues?: pulumi.Input<boolean>;
    /**
     * Whether to use XMLHttpRequest (XHR) when taking measurements.
     */
    useXhr?: pulumi.Input<boolean>;
}

export interface DatasetDatatype {
    data: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    scope: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface DatasetRepeat {
    endAfterN: pulumi.Input<number>;
    repeatsEvery: pulumi.Input<string>;
    start: pulumi.Input<number>;
}

export interface DatasetReport {
    createdAt?: pulumi.Input<number>;
    end?: pulumi.Input<number>;
    id?: pulumi.Input<string>;
    start?: pulumi.Input<number>;
    status?: pulumi.Input<string>;
}

export interface DatasetTimeframe {
    aggregation: pulumi.Input<string>;
    cycles?: pulumi.Input<number>;
    from?: pulumi.Input<number>;
    to?: pulumi.Input<number>;
}

export interface GetMonitoringRegionsRegion {
    /**
     * 3-letter city code identifying the location of the monitor.
     */
    code?: string;
    /**
     * City name identifying the location of the monitor.
     */
    name?: string;
    /**
     * A list of IPv4 and IPv6 subnets the monitor sources requests from.
     */
    subnets?: string[];
}

export interface GetMonitoringRegionsRegionArgs {
    /**
     * 3-letter city code identifying the location of the monitor.
     */
    code?: pulumi.Input<string>;
    /**
     * City name identifying the location of the monitor.
     */
    name?: pulumi.Input<string>;
    /**
     * A list of IPv4 and IPv6 subnets the monitor sources requests from.
     */
    subnets?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface MonitoringJobRule {
    comparison: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface NotifyListNotification {
    /**
     * Configuration details for the given notifier type.
     */
    config: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
     */
    type: pulumi.Input<string>;
}

export interface PulsarJobBlendMetricWeights {
    timestamp: pulumi.Input<number>;
}

export interface PulsarJobConfig {
    host?: pulumi.Input<string>;
    http?: pulumi.Input<boolean>;
    https?: pulumi.Input<boolean>;
    jobTimeoutMillis?: pulumi.Input<number>;
    requestTimeoutMillis?: pulumi.Input<number>;
    staticValues?: pulumi.Input<boolean>;
    urlPath?: pulumi.Input<string>;
    useXhr?: pulumi.Input<boolean>;
}

export interface PulsarJobWeight {
    defaultValue: pulumi.Input<number>;
    maximize?: pulumi.Input<boolean>;
    name: pulumi.Input<string>;
    weight: pulumi.Input<number>;
}

export interface RecordAnswer {
    /**
     * Space delimited string of RDATA fields dependent on the record type.
     *
     * A:
     *
     * answer = "1.2.3.4"
     *
     * CNAME:
     *
     * answer = "www.example.com"
     *
     * MX:
     *
     * answer = "5 mail.example.com"
     *
     * SRV:
     *
     * answer = "10 0 2380 node-1.example.com"
     *
     * SPF:
     *
     * answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
     *
     * Optionally, the individual parts of the answer can be expressed as a list in the field `answerParts`.
     * Only one of `answer` or `answerParts` can be specified.
     */
    answer?: pulumi.Input<string>;
    /**
     * A list of individual RDATA fields. This field cannot be set together with `answer`
     */
    answerParts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * meta is supported at the `regions` level. Meta
     * is documented below.
     * Note that `Meta` values for `country`, `caProvince`, `georegion`, and
     * `usState` should be comma separated strings, and changes in ordering will not
     * lead to terraform detecting a change.
     *
     * Note: regions **must** be sorted lexically by their "name" argument in the
     * Terraform configuration file, otherwise Terraform will detect changes to the
     * record when none actually exist.
     */
    meta?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The region (Answer Group really) that this answer
     * belongs to. This should be one of the names specified in `regions`. Only a
     * single `region` per answer is currently supported. If you want an answer in
     * multiple regions, duplicating the answer (including metadata) is the correct
     * approach.
     * * ` meta` - (Optional) meta is supported at the `answer` level. Meta
     * is documented below.
     */
    region?: pulumi.Input<string>;
}

export interface RecordFilter {
    /**
     * The filters' configuration. Simple key/value pairs
     * determined by the filter type.
     */
    config?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Determines whether the filter is applied in the
     * filter chain.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The type of filter.
     */
    filter: pulumi.Input<string>;
}

export interface RecordRegion {
    /**
     * meta is supported at the `regions` level. Meta
     * is documented below.
     * Note that `Meta` values for `country`, `caProvince`, `georegion`, and
     * `usState` should be comma separated strings, and changes in ordering will not
     * lead to terraform detecting a change.
     *
     * Note: regions **must** be sorted lexically by their "name" argument in the
     * Terraform configuration file, otherwise Terraform will detect changes to the
     * record when none actually exist.
     */
    meta?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Name of the region (or Answer Group).
     */
    name: pulumi.Input<string>;
}

export interface TeamDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface TeamDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface TeamIpWhitelist {
    /**
     * The free form name of the team.
     */
    name: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserDnsRecordsAllow {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface UserDnsRecordsDeny {
    domain: pulumi.Input<string>;
    includeSubdomains: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface ZoneSecondary {
    /**
     * IPv4 address of the secondary server.
     */
    ip: pulumi.Input<string>;
    /**
     * List of network IDs (`int`) for which the zone
     * should be made available. Default is network 0, the primary NSONE Global
     * Network. Normally, you should not have to worry about this.
     */
    networks?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Whether we send `NOTIFY` messages to the secondary host
     * when the zone changes. Default `false`.
     */
    notify?: pulumi.Input<boolean>;
    /**
     * Port of the the secondary server. Default `53`.
     */
    port?: pulumi.Input<number>;
}
