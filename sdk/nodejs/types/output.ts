// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface APIKeyDnsRecordsAllow {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface APIKeyDnsRecordsDeny {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface AlertData {
    /**
     * required by the account/usage alerts, with a value between 1 and 100
     */
    alertAtPercent?: number;
}

export interface ApplicationDefaultConfig {
    /**
     * Indicates whether or not to use HTTP in measurements.
     */
    http: boolean;
    /**
     * Indicates whether or not to use HTTPS in measurements.
     */
    https?: boolean;
    /**
     * Maximum timeout per job
     * 0, the primary NSONE Global Network. Normally, you should not have to worry about this.
     */
    jobTimeoutMillis?: number;
    /**
     * Maximum timeout per request.
     */
    requestTimeoutMillis?: number;
    /**
     * Indicates whether or not to skip aggregation for this job's measurements
     */
    staticValues?: boolean;
    /**
     * Whether to use XMLHttpRequest (XHR) when taking measurements.
     */
    useXhr?: boolean;
}

export interface DatasetDatatype {
    data: {[key: string]: string};
    scope: string;
    type: string;
}

export interface DatasetRepeat {
    endAfterN: number;
    repeatsEvery: string;
    start: number;
}

export interface DatasetReport {
    createdAt: number;
    end: number;
    id: string;
    start: number;
    status: string;
}

export interface DatasetTimeframe {
    aggregation: string;
    cycles?: number;
    from?: number;
    to?: number;
}

export interface GetBillingUsageByNetwork {
    /**
     * Total billable queries for this network.
     */
    billableQueries: number;
    /**
     * Clean queries for this day.
     */
    cleanQueries: number;
    /**
     * Daily breakdown containing:
     */
    dailies: outputs.GetBillingUsageByNetworkDaily[];
    /**
     * DDoS queries for this day.
     */
    ddosQueries: number;
    /**
     * The network ID.
     */
    network: number;
    /**
     * NXD responses for this day.
     */
    nxdResponses: number;
}

export interface GetBillingUsageByNetworkDaily {
    /**
     * Clean queries for this day.
     */
    cleanQueries: number;
    /**
     * DDoS queries for this day.
     */
    ddosQueries: number;
    /**
     * NXD responses for this day.
     */
    nxdResponses: number;
    /**
     * The timestamp for the day.
     */
    timestamp: number;
}

export interface GetDNSSecDelegation {
    /**
     * (Computed) List of Keys. Key is documented below.
     */
    dnskeys: outputs.GetDNSSecDelegationDnskey[];
    /**
     * (Computed) List of Keys. Key is documented below.
     */
    ds: outputs.GetDNSSecDelegationD[];
    /**
     * (Computed) TTL for the Keys (int).
     */
    ttl: number;
}

export interface GetDNSSecDelegationD {
    /**
     * (Computed) Algorithm of the key.
     */
    algorithm: string;
    /**
     * (Computed) Flags for the key.
     */
    flags: string;
    /**
     * (Computed) Protocol of the key.
     */
    protocol: string;
    /**
     * (Computed) Public key for the key.
     */
    publicKey: string;
}

export interface GetDNSSecDelegationDnskey {
    /**
     * (Computed) Algorithm of the key.
     */
    algorithm: string;
    /**
     * (Computed) Flags for the key.
     */
    flags: string;
    /**
     * (Computed) Protocol of the key.
     */
    protocol: string;
    /**
     * (Computed) Public key for the key.
     */
    publicKey: string;
}

export interface GetDNSSecKey {
    /**
     * (Computed) List of Keys. Key is documented below.
     */
    dnskeys: outputs.GetDNSSecKeyDnskey[];
    /**
     * (Computed) TTL for the Keys (int).
     */
    ttl: number;
}

export interface GetDNSSecKeyDnskey {
    /**
     * (Computed) Algorithm of the key.
     */
    algorithm: string;
    /**
     * (Computed) Flags for the key.
     */
    flags: string;
    /**
     * (Computed) Protocol of the key.
     */
    protocol: string;
    /**
     * (Computed) Public key for the key.
     */
    publicKey: string;
}

export interface GetMonitoringRegionsRegion {
    /**
     * 3-letter city code identifying the location of the monitor.
     */
    code?: string;
    /**
     * City name identifying the location of the monitor.
     */
    name?: string;
    /**
     * A list of IPv4 and IPv6 subnets the monitor sources requests from.
     */
    subnets?: string[];
}

export interface GetNetworksNetwork {
    /**
     * Label associated with the network.
     */
    label: string;
    /**
     * Name of the network.
     */
    name: string;
    /**
     * network ID (`int`). Default is network 0, the primary NS1 Managed DNS Network.
     */
    networkId: number;
}

export interface GetRecordAnswer {
    answer: string;
    /**
     * Map of metadata
     */
    meta: {[key: string]: string};
    region: string;
}

export interface GetRecordFilter {
    config: {[key: string]: string};
    disabled: boolean;
    filter: string;
}

export interface GetRecordRegion {
    /**
     * Map of metadata
     */
    meta: {[key: string]: string};
    name: string;
}

export interface GetZoneSecondary {
    /**
     * IPv4 address of the secondary server.
     */
    ip: string;
    /**
     * List of network IDs (`int`) for which the zone should be made
     * available. Default is network 0, the primary NSONE Global Network.
     */
    networks: number[];
    /**
     * Whether we send `NOTIFY` messages to the secondary host
     * when the zone changes. Default `false`.
     */
    notify: boolean;
    /**
     * Port of the the secondary server. Default `53`.
     */
    port: number;
}

export interface MonitoringJobRule {
    comparison: string;
    key: string;
    value: string;
}

export interface NotifyListNotification {
    /**
     * Configuration details for the given notifier type.
     */
    config: {[key: string]: string};
    /**
     * The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
     */
    type: string;
}

export interface PulsarJobBlendMetricWeights {
    timestamp: number;
}

export interface PulsarJobConfig {
    host?: string;
    http?: boolean;
    https?: boolean;
    jobTimeoutMillis?: number;
    requestTimeoutMillis?: number;
    staticValues?: boolean;
    urlPath?: string;
    useXhr?: boolean;
}

export interface PulsarJobWeight {
    defaultValue: number;
    maximize?: boolean;
    name: string;
    weight: number;
}

export interface RecordAnswer {
    /**
     * Space delimited string of RDATA fields dependent on the record type.
     *
     * A:
     *
     * answer = "1.2.3.4"
     *
     * CNAME:
     *
     * answer = "www.example.com"
     *
     * MX:
     *
     * answer = "5 mail.example.com"
     *
     * SRV:
     *
     * answer = "10 0 2380 node-1.example.com"
     *
     * SPF:
     *
     * answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
     *
     * Optionally, the individual parts of the answer can be expressed as a list in the field `answerParts`.
     * Only one of `answer` or `answerParts` can be specified.
     */
    answer?: string;
    /**
     * A list of individual RDATA fields. This field cannot be set together with `answer`
     */
    answerParts?: string[];
    meta?: {[key: string]: string};
    /**
     * The region (Answer Group really) that this answer
     * belongs to. This should be one of the names specified in `regions`. Only a
     * single `region` per answer is currently supported. If you want an answer in
     * multiple regions, duplicating the answer (including metadata) is the correct
     * approach.
     * * ` meta` - (Optional) meta is supported at the `answer` level. Meta
     * is documented below.
     */
    region?: string;
}

export interface RecordFilter {
    /**
     * The filters' configuration. Simple key/value pairs
     * determined by the filter type.
     */
    config?: {[key: string]: string};
    /**
     * Determines whether the filter is applied in the
     * filter chain.
     */
    disabled?: boolean;
    /**
     * The type of filter.
     */
    filter: string;
}

export interface RecordRegion {
    meta?: {[key: string]: string};
    /**
     * Name of the region (or Answer Group).
     */
    name: string;
}

export interface TeamDnsRecordsAllow {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface TeamDnsRecordsDeny {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface TeamIpWhitelist {
    /**
     * The free form name of the team.
     */
    name: string;
    values: string[];
}

export interface UserDnsRecordsAllow {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface UserDnsRecordsDeny {
    domain: string;
    includeSubdomains: boolean;
    type: string;
    zone: string;
}

export interface ZoneSecondary {
    /**
     * IPv4 address of the secondary server.
     */
    ip: string;
    /**
     * List of network IDs (`int`) for which the zone
     * should be made available. Default is network 0, the primary NSONE Global
     * Network. Normally, you should not have to worry about this.
     */
    networks: number[];
    /**
     * Whether we send `NOTIFY` messages to the secondary host
     * when the zone changes. Default `false`.
     */
    notify: boolean;
    /**
     * Port of the the secondary server. Default `53`.
     */
    port: number;
}

