# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'APIKeyDnsRecordsAllow',
    'APIKeyDnsRecordsDeny',
    'ApplicationDefaultConfig',
    'DatasetDatatype',
    'DatasetRepeat',
    'DatasetReport',
    'DatasetTimeframe',
    'MonitoringJobRule',
    'NotifyListNotification',
    'PulsarJobBlendMetricWeights',
    'PulsarJobConfig',
    'PulsarJobWeight',
    'RecordAnswer',
    'RecordFilter',
    'RecordRegion',
    'TeamDnsRecordsAllow',
    'TeamDnsRecordsDeny',
    'TeamIpWhitelist',
    'UserDnsRecordsAllow',
    'UserDnsRecordsDeny',
    'ZoneSecondary',
    'GetBillingUsageByNetworkResult',
    'GetBillingUsageByNetworkDailyResult',
    'GetDNSSecDelegationResult',
    'GetDNSSecDelegationDResult',
    'GetDNSSecDelegationDnskeyResult',
    'GetDNSSecKeyResult',
    'GetDNSSecKeyDnskeyResult',
    'GetMonitoringRegionsRegionResult',
    'GetNetworksNetworkResult',
    'GetRecordAnswerResult',
    'GetRecordFilterResult',
    'GetRecordRegionResult',
    'GetZoneSecondaryResult',
]

@pulumi.output_type
class APIKeyDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in APIKeyDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        APIKeyDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        APIKeyDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class APIKeyDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in APIKeyDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        APIKeyDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        APIKeyDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class ApplicationDefaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTimeoutMillis":
            suggest = "job_timeout_millis"
        elif key == "requestTimeoutMillis":
            suggest = "request_timeout_millis"
        elif key == "staticValues":
            suggest = "static_values"
        elif key == "useXhr":
            suggest = "use_xhr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDefaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDefaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDefaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http: builtins.bool,
                 https: Optional[builtins.bool] = None,
                 job_timeout_millis: Optional[builtins.int] = None,
                 request_timeout_millis: Optional[builtins.int] = None,
                 static_values: Optional[builtins.bool] = None,
                 use_xhr: Optional[builtins.bool] = None):
        """
        :param builtins.bool http: Indicates whether or not to use HTTP in measurements.
        :param builtins.bool https: Indicates whether or not to use HTTPS in measurements.
        :param builtins.int job_timeout_millis: Maximum timeout per job
               0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        :param builtins.int request_timeout_millis: Maximum timeout per request.
        :param builtins.bool static_values: Indicates whether or not to skip aggregation for this job's measurements
        :param builtins.bool use_xhr: Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if job_timeout_millis is not None:
            pulumi.set(__self__, "job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            pulumi.set(__self__, "request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            pulumi.set(__self__, "static_values", static_values)
        if use_xhr is not None:
            pulumi.set(__self__, "use_xhr", use_xhr)

    @property
    @pulumi.getter
    def http(self) -> builtins.bool:
        """
        Indicates whether or not to use HTTP in measurements.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def https(self) -> Optional[builtins.bool]:
        """
        Indicates whether or not to use HTTPS in measurements.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[builtins.int]:
        """
        Maximum timeout per job
        0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "job_timeout_millis")

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[builtins.int]:
        """
        Maximum timeout per request.
        """
        return pulumi.get(self, "request_timeout_millis")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[builtins.bool]:
        """
        Indicates whether or not to skip aggregation for this job's measurements
        """
        return pulumi.get(self, "static_values")

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[builtins.bool]:
        """
        Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        return pulumi.get(self, "use_xhr")


@pulumi.output_type
class DatasetDatatype(dict):
    def __init__(__self__, *,
                 data: Mapping[str, builtins.str],
                 scope: builtins.str,
                 type: builtins.str):
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def data(self) -> Mapping[str, builtins.str]:
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def scope(self) -> builtins.str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAfterN":
            suggest = "end_after_n"
        elif key == "repeatsEvery":
            suggest = "repeats_every"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_after_n: builtins.int,
                 repeats_every: builtins.str,
                 start: builtins.int):
        pulumi.set(__self__, "end_after_n", end_after_n)
        pulumi.set(__self__, "repeats_every", repeats_every)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="endAfterN")
    def end_after_n(self) -> builtins.int:
        return pulumi.get(self, "end_after_n")

    @property
    @pulumi.getter(name="repeatsEvery")
    def repeats_every(self) -> builtins.str:
        return pulumi.get(self, "repeats_every")

    @property
    @pulumi.getter
    def start(self) -> builtins.int:
        return pulumi.get(self, "start")


@pulumi.output_type
class DatasetReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.int] = None,
                 end: Optional[builtins.int] = None,
                 id: Optional[builtins.str] = None,
                 start: Optional[builtins.int] = None,
                 status: Optional[builtins.str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.int]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def end(self) -> Optional[builtins.int]:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def start(self) -> Optional[builtins.int]:
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DatasetTimeframe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetTimeframe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetTimeframe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetTimeframe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: builtins.str,
                 cycles: Optional[builtins.int] = None,
                 from_: Optional[builtins.int] = None,
                 to: Optional[builtins.int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if cycles is not None:
            pulumi.set(__self__, "cycles", cycles)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def aggregation(self) -> builtins.str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def cycles(self) -> Optional[builtins.int]:
        return pulumi.get(self, "cycles")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[builtins.int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[builtins.int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class MonitoringJobRule(dict):
    def __init__(__self__, *,
                 comparison: builtins.str,
                 key: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> builtins.str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotifyListNotification(dict):
    def __init__(__self__, *,
                 config: Mapping[str, builtins.str],
                 type: builtins.str):
        """
        :param Mapping[str, builtins.str] config: Configuration details for the given notifier type.
        :param builtins.str type: The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, builtins.str]:
        """
        Configuration details for the given notifier type.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PulsarJobBlendMetricWeights(dict):
    def __init__(__self__, *,
                 timestamp: builtins.int):
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def timestamp(self) -> builtins.int:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class PulsarJobConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTimeoutMillis":
            suggest = "job_timeout_millis"
        elif key == "requestTimeoutMillis":
            suggest = "request_timeout_millis"
        elif key == "staticValues":
            suggest = "static_values"
        elif key == "urlPath":
            suggest = "url_path"
        elif key == "useXhr":
            suggest = "use_xhr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PulsarJobConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PulsarJobConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PulsarJobConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[builtins.str] = None,
                 http: Optional[builtins.bool] = None,
                 https: Optional[builtins.bool] = None,
                 job_timeout_millis: Optional[builtins.int] = None,
                 request_timeout_millis: Optional[builtins.int] = None,
                 static_values: Optional[builtins.bool] = None,
                 url_path: Optional[builtins.str] = None,
                 use_xhr: Optional[builtins.bool] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if job_timeout_millis is not None:
            pulumi.set(__self__, "job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            pulumi.set(__self__, "request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            pulumi.set(__self__, "static_values", static_values)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)
        if use_xhr is not None:
            pulumi.set(__self__, "use_xhr", use_xhr)

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def https(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[builtins.int]:
        return pulumi.get(self, "job_timeout_millis")

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[builtins.int]:
        return pulumi.get(self, "request_timeout_millis")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "static_values")

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "url_path")

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_xhr")


@pulumi.output_type
class PulsarJobWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PulsarJobWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PulsarJobWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PulsarJobWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: builtins.float,
                 name: builtins.str,
                 weight: builtins.int,
                 maximize: Optional[builtins.bool] = None):
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "weight", weight)
        if maximize is not None:
            pulumi.set(__self__, "maximize", maximize)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> builtins.float:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def weight(self) -> builtins.int:
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def maximize(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "maximize")


@pulumi.output_type
class RecordAnswer(dict):
    def __init__(__self__, *,
                 answer: Optional[builtins.str] = None,
                 meta: Optional[Mapping[str, builtins.str]] = None,
                 region: Optional[builtins.str] = None):
        """
        :param builtins.str answer: Space delimited string of RDATA fields dependent on the record type.
               
               A:
               
               answer = "1.2.3.4"
               
               CNAME:
               
               answer = "www.example.com"
               
               MX:
               
               answer = "5 mail.example.com"
               
               SRV:
               
               answer = "10 0 2380 node-1.example.com"
               
               SPF:
               
               answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        :param builtins.str region: The region (Answer Group really) that this answer
               belongs to. This should be one of the names specified in `regions`. Only a
               single `region` per answer is currently supported. If you want an answer in
               multiple regions, duplicating the answer (including metadata) is the correct
               approach.
               * ` meta` - (Optional) meta is supported at the `answer` level. Meta
               is documented below.
        """
        if answer is not None:
            pulumi.set(__self__, "answer", answer)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def answer(self) -> Optional[builtins.str]:
        """
        Space delimited string of RDATA fields dependent on the record type.

        A:

        answer = "1.2.3.4"

        CNAME:

        answer = "www.example.com"

        MX:

        answer = "5 mail.example.com"

        SRV:

        answer = "10 0 2380 node-1.example.com"

        SPF:

        answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        """
        return pulumi.get(self, "answer")

    @property
    @pulumi.getter
    def meta(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        The region (Answer Group really) that this answer
        belongs to. This should be one of the names specified in `regions`. Only a
        single `region` per answer is currently supported. If you want an answer in
        multiple regions, duplicating the answer (including metadata) is the correct
        approach.
        * ` meta` - (Optional) meta is supported at the `answer` level. Meta
        is documented below.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class RecordFilter(dict):
    def __init__(__self__, *,
                 filter: builtins.str,
                 config: Optional[Mapping[str, builtins.str]] = None,
                 disabled: Optional[builtins.bool] = None):
        """
        :param builtins.str filter: The type of filter.
        :param Mapping[str, builtins.str] config: The filters' configuration. Simple key/value pairs
               determined by the filter type.
        :param builtins.bool disabled: Determines whether the filter is applied in the
               filter chain.
        """
        pulumi.set(__self__, "filter", filter)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def filter(self) -> builtins.str:
        """
        The type of filter.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The filters' configuration. Simple key/value pairs
        determined by the filter type.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[builtins.bool]:
        """
        Determines whether the filter is applied in the
        filter chain.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class RecordRegion(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 meta: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: Name of the region (or Answer Group).
        """
        pulumi.set(__self__, "name", name)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the region (or Answer Group).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def meta(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "meta")


@pulumi.output_type
class TeamDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class TeamDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class TeamIpWhitelist(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str name: The free form name of the team.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The free form name of the team.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class UserDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class UserDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 include_subdomains: builtins.bool,
                 type: builtins.str,
                 zone: builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class ZoneSecondary(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 networks: Optional[Sequence[builtins.int]] = None,
                 notify: Optional[builtins.bool] = None,
                 port: Optional[builtins.int] = None):
        """
        :param builtins.str ip: IPv4 address of the secondary server.
        :param Sequence[builtins.int] networks: List of network IDs (`int`) for which the zone
               should be made available. Default is network 0, the primary NSONE Global
               Network. Normally, you should not have to worry about this.
        :param builtins.bool notify: Whether we send `NOTIFY` messages to the secondary host
               when the zone changes. Default `false`.
        :param builtins.int port: Port of the the secondary server. Default `53`.
        """
        pulumi.set(__self__, "ip", ip)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if notify is not None:
            pulumi.set(__self__, "notify", notify)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        IPv4 address of the secondary server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[builtins.int]]:
        """
        List of network IDs (`int`) for which the zone
        should be made available. Default is network 0, the primary NSONE Global
        Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def notify(self) -> Optional[builtins.bool]:
        """
        Whether we send `NOTIFY` messages to the secondary host
        when the zone changes. Default `false`.
        """
        return pulumi.get(self, "notify")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        Port of the the secondary server. Default `53`.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetBillingUsageByNetworkResult(dict):
    def __init__(__self__, *,
                 billable_queries: builtins.int,
                 clean_queries: builtins.int,
                 dailies: Sequence['outputs.GetBillingUsageByNetworkDailyResult'],
                 ddos_queries: builtins.int,
                 network: builtins.int,
                 nxd_responses: builtins.int):
        """
        :param builtins.int billable_queries: Total billable queries for this network.
        :param builtins.int clean_queries: Clean queries for this day.
        :param Sequence['GetBillingUsageByNetworkDailyArgs'] dailies: Daily breakdown containing:
        :param builtins.int ddos_queries: DDoS queries for this day.
        :param builtins.int network: The network ID.
        :param builtins.int nxd_responses: NXD responses for this day.
        """
        pulumi.set(__self__, "billable_queries", billable_queries)
        pulumi.set(__self__, "clean_queries", clean_queries)
        pulumi.set(__self__, "dailies", dailies)
        pulumi.set(__self__, "ddos_queries", ddos_queries)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "nxd_responses", nxd_responses)

    @property
    @pulumi.getter(name="billableQueries")
    def billable_queries(self) -> builtins.int:
        """
        Total billable queries for this network.
        """
        return pulumi.get(self, "billable_queries")

    @property
    @pulumi.getter(name="cleanQueries")
    def clean_queries(self) -> builtins.int:
        """
        Clean queries for this day.
        """
        return pulumi.get(self, "clean_queries")

    @property
    @pulumi.getter
    def dailies(self) -> Sequence['outputs.GetBillingUsageByNetworkDailyResult']:
        """
        Daily breakdown containing:
        """
        return pulumi.get(self, "dailies")

    @property
    @pulumi.getter(name="ddosQueries")
    def ddos_queries(self) -> builtins.int:
        """
        DDoS queries for this day.
        """
        return pulumi.get(self, "ddos_queries")

    @property
    @pulumi.getter
    def network(self) -> builtins.int:
        """
        The network ID.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="nxdResponses")
    def nxd_responses(self) -> builtins.int:
        """
        NXD responses for this day.
        """
        return pulumi.get(self, "nxd_responses")


@pulumi.output_type
class GetBillingUsageByNetworkDailyResult(dict):
    def __init__(__self__, *,
                 clean_queries: builtins.int,
                 ddos_queries: builtins.int,
                 nxd_responses: builtins.int,
                 timestamp: builtins.int):
        """
        :param builtins.int clean_queries: Clean queries for this day.
        :param builtins.int ddos_queries: DDoS queries for this day.
        :param builtins.int nxd_responses: NXD responses for this day.
        :param builtins.int timestamp: The timestamp for the day.
        """
        pulumi.set(__self__, "clean_queries", clean_queries)
        pulumi.set(__self__, "ddos_queries", ddos_queries)
        pulumi.set(__self__, "nxd_responses", nxd_responses)
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="cleanQueries")
    def clean_queries(self) -> builtins.int:
        """
        Clean queries for this day.
        """
        return pulumi.get(self, "clean_queries")

    @property
    @pulumi.getter(name="ddosQueries")
    def ddos_queries(self) -> builtins.int:
        """
        DDoS queries for this day.
        """
        return pulumi.get(self, "ddos_queries")

    @property
    @pulumi.getter(name="nxdResponses")
    def nxd_responses(self) -> builtins.int:
        """
        NXD responses for this day.
        """
        return pulumi.get(self, "nxd_responses")

    @property
    @pulumi.getter
    def timestamp(self) -> builtins.int:
        """
        The timestamp for the day.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetDNSSecDelegationResult(dict):
    def __init__(__self__, *,
                 dnskeys: Sequence['outputs.GetDNSSecDelegationDnskeyResult'],
                 ds: Sequence['outputs.GetDNSSecDelegationDResult'],
                 ttl: builtins.int):
        """
        :param Sequence['GetDNSSecDelegationDnskeyArgs'] dnskeys: (Computed) List of Keys. Key is documented below.
        :param Sequence['GetDNSSecDelegationDArgs'] ds: (Computed) List of Keys. Key is documented below.
        :param builtins.int ttl: (Computed) TTL for the Keys (int).
        """
        pulumi.set(__self__, "dnskeys", dnskeys)
        pulumi.set(__self__, "ds", ds)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def dnskeys(self) -> Sequence['outputs.GetDNSSecDelegationDnskeyResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "dnskeys")

    @property
    @pulumi.getter
    def ds(self) -> Sequence['outputs.GetDNSSecDelegationDResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "ds")

    @property
    @pulumi.getter
    def ttl(self) -> builtins.int:
        """
        (Computed) TTL for the Keys (int).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetDNSSecDelegationDResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 flags: builtins.str,
                 protocol: builtins.str,
                 public_key: builtins.str):
        """
        :param builtins.str algorithm: (Computed) Algorithm of the key.
        :param builtins.str flags: (Computed) Flags for the key.
        :param builtins.str protocol: (Computed) Protocol of the key.
        :param builtins.str public_key: (Computed) Public key for the key.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> builtins.str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetDNSSecDelegationDnskeyResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 flags: builtins.str,
                 protocol: builtins.str,
                 public_key: builtins.str):
        """
        :param builtins.str algorithm: (Computed) Algorithm of the key.
        :param builtins.str flags: (Computed) Flags for the key.
        :param builtins.str protocol: (Computed) Protocol of the key.
        :param builtins.str public_key: (Computed) Public key for the key.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> builtins.str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetDNSSecKeyResult(dict):
    def __init__(__self__, *,
                 dnskeys: Sequence['outputs.GetDNSSecKeyDnskeyResult'],
                 ttl: builtins.int):
        """
        :param Sequence['GetDNSSecKeyDnskeyArgs'] dnskeys: (Computed) List of Keys. Key is documented below.
        :param builtins.int ttl: (Computed) TTL for the Keys (int).
        """
        pulumi.set(__self__, "dnskeys", dnskeys)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def dnskeys(self) -> Sequence['outputs.GetDNSSecKeyDnskeyResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "dnskeys")

    @property
    @pulumi.getter
    def ttl(self) -> builtins.int:
        """
        (Computed) TTL for the Keys (int).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetDNSSecKeyDnskeyResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 flags: builtins.str,
                 protocol: builtins.str,
                 public_key: builtins.str):
        """
        :param builtins.str algorithm: (Computed) Algorithm of the key.
        :param builtins.str flags: (Computed) Flags for the key.
        :param builtins.str protocol: (Computed) Protocol of the key.
        :param builtins.str public_key: (Computed) Public key for the key.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> builtins.str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetMonitoringRegionsRegionResult(dict):
    def __init__(__self__, *,
                 code: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 subnets: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str code: 3-letter city code identifying the location of the monitor.
        :param builtins.str name: City name identifying the location of the monitor.
        :param Sequence[builtins.str] subnets: A list of IPv4 and IPv6 subnets the monitor sources requests from.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def code(self) -> Optional[builtins.str]:
        """
        3-letter city code identifying the location of the monitor.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        City name identifying the location of the monitor.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of IPv4 and IPv6 subnets the monitor sources requests from.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetNetworksNetworkResult(dict):
    def __init__(__self__, *,
                 label: builtins.str,
                 name: builtins.str,
                 network_id: builtins.int):
        """
        :param builtins.str label: Label associated with the network.
        :param builtins.str name: Name of the network.
        :param builtins.int network_id: network ID (`int`). Default is network 0, the primary NS1 Managed DNS Network.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter
    def label(self) -> builtins.str:
        """
        Label associated with the network.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the network.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> builtins.int:
        """
        network ID (`int`). Default is network 0, the primary NS1 Managed DNS Network.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class GetRecordAnswerResult(dict):
    def __init__(__self__, *,
                 answer: builtins.str,
                 meta: Mapping[str, builtins.str],
                 region: builtins.str):
        """
        :param Mapping[str, builtins.str] meta: Map of metadata
        """
        pulumi.set(__self__, "answer", answer)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def answer(self) -> builtins.str:
        return pulumi.get(self, "answer")

    @property
    @pulumi.getter
    def meta(self) -> Mapping[str, builtins.str]:
        """
        Map of metadata
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetRecordFilterResult(dict):
    def __init__(__self__, *,
                 config: Mapping[str, builtins.str],
                 disabled: builtins.bool,
                 filter: builtins.str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, builtins.str]:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> builtins.bool:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def filter(self) -> builtins.str:
        return pulumi.get(self, "filter")


@pulumi.output_type
class GetRecordRegionResult(dict):
    def __init__(__self__, *,
                 meta: Mapping[str, builtins.str],
                 name: builtins.str):
        """
        :param Mapping[str, builtins.str] meta: Map of metadata
        """
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def meta(self) -> Mapping[str, builtins.str]:
        """
        Map of metadata
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZoneSecondaryResult(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 networks: Sequence[builtins.int],
                 notify: builtins.bool,
                 port: builtins.int):
        """
        :param builtins.str ip: IPv4 address of the secondary server.
        :param Sequence[builtins.int] networks: List of network IDs (`int`) for which the zone should be made
               available. Default is network 0, the primary NSONE Global Network.
        :param builtins.bool notify: Whether we send `NOTIFY` messages to the secondary host
               when the zone changes. Default `false`.
        :param builtins.int port: Port of the the secondary server. Default `53`.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "notify", notify)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        IPv4 address of the secondary server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def networks(self) -> Sequence[builtins.int]:
        """
        List of network IDs (`int`) for which the zone should be made
        available. Default is network 0, the primary NSONE Global Network.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def notify(self) -> builtins.bool:
        """
        Whether we send `NOTIFY` messages to the secondary host
        when the zone changes. Default `false`.
        """
        return pulumi.get(self, "notify")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        Port of the the secondary server. Default `53`.
        """
        return pulumi.get(self, "port")


