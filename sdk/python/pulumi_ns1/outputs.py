# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'APIKeyDnsRecordsAllow',
    'APIKeyDnsRecordsDeny',
    'ApplicationDefaultConfig',
    'MonitoringJobRule',
    'NotifyListNotification',
    'PulsarJobBlendMetricWeights',
    'PulsarJobConfig',
    'PulsarJobWeight',
    'RecordAnswer',
    'RecordFilter',
    'RecordRegion',
    'TeamDnsRecordsAllow',
    'TeamDnsRecordsDeny',
    'TeamIpWhitelist',
    'UserDnsRecordsAllow',
    'UserDnsRecordsDeny',
    'ZoneSecondary',
    'GetDNSSecDelegationResult',
    'GetDNSSecDelegationDResult',
    'GetDNSSecDelegationDnskeyResult',
    'GetDNSSecKeyResult',
    'GetDNSSecKeyDnskeyResult',
    'GetNetworksNetworkResult',
    'GetRecordAnswerResult',
    'GetRecordFilterResult',
    'GetRecordRegionResult',
    'GetZoneSecondaryResult',
]

@pulumi.output_type
class APIKeyDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in APIKeyDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        APIKeyDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        APIKeyDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        APIKeyDnsRecordsAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class APIKeyDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in APIKeyDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        APIKeyDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        APIKeyDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        APIKeyDnsRecordsDeny._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class ApplicationDefaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTimeoutMillis":
            suggest = "job_timeout_millis"
        elif key == "requestTimeoutMillis":
            suggest = "request_timeout_millis"
        elif key == "staticValues":
            suggest = "static_values"
        elif key == "useXhr":
            suggest = "use_xhr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDefaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDefaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDefaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http: bool,
                 https: Optional[bool] = None,
                 job_timeout_millis: Optional[int] = None,
                 request_timeout_millis: Optional[int] = None,
                 static_values: Optional[bool] = None,
                 use_xhr: Optional[bool] = None):
        """
        :param bool http: Indicates whether or not to use HTTP in measurements.
        :param bool https: Indicates whether or not to use HTTPS in measurements.
        :param int job_timeout_millis: Maximum timeout per job
               0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        :param int request_timeout_millis: Maximum timeout per request.
        :param bool static_values: Indicates whether or not to skip aggregation for this job's measurements
        :param bool use_xhr: Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        ApplicationDefaultConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http=http,
            https=https,
            job_timeout_millis=job_timeout_millis,
            request_timeout_millis=request_timeout_millis,
            static_values=static_values,
            use_xhr=use_xhr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http: bool,
             https: Optional[bool] = None,
             job_timeout_millis: Optional[int] = None,
             request_timeout_millis: Optional[int] = None,
             static_values: Optional[bool] = None,
             use_xhr: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("http", http)
        if https is not None:
            _setter("https", https)
        if job_timeout_millis is not None:
            _setter("job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            _setter("request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            _setter("static_values", static_values)
        if use_xhr is not None:
            _setter("use_xhr", use_xhr)

    @property
    @pulumi.getter
    def http(self) -> bool:
        """
        Indicates whether or not to use HTTP in measurements.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def https(self) -> Optional[bool]:
        """
        Indicates whether or not to use HTTPS in measurements.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[int]:
        """
        Maximum timeout per job
        0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "job_timeout_millis")

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[int]:
        """
        Maximum timeout per request.
        """
        return pulumi.get(self, "request_timeout_millis")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[bool]:
        """
        Indicates whether or not to skip aggregation for this job's measurements
        """
        return pulumi.get(self, "static_values")

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[bool]:
        """
        Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        return pulumi.get(self, "use_xhr")


@pulumi.output_type
class MonitoringJobRule(dict):
    def __init__(__self__, *,
                 comparison: str,
                 key: str,
                 value: str):
        MonitoringJobRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison=comparison,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison: str,
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparison", comparison)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotifyListNotification(dict):
    def __init__(__self__, *,
                 config: Mapping[str, Any],
                 type: str):
        """
        :param Mapping[str, Any] config: Configuration details for the given notifier type.
        :param str type: The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        NotifyListNotification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Mapping[str, Any],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config", config)
        _setter("type", type)

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, Any]:
        """
        Configuration details for the given notifier type.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PulsarJobBlendMetricWeights(dict):
    def __init__(__self__, *,
                 timestamp: int):
        PulsarJobBlendMetricWeights._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timestamp: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timestamp", timestamp)

    @property
    @pulumi.getter
    def timestamp(self) -> int:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class PulsarJobConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTimeoutMillis":
            suggest = "job_timeout_millis"
        elif key == "requestTimeoutMillis":
            suggest = "request_timeout_millis"
        elif key == "staticValues":
            suggest = "static_values"
        elif key == "urlPath":
            suggest = "url_path"
        elif key == "useXhr":
            suggest = "use_xhr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PulsarJobConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PulsarJobConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PulsarJobConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http: Optional[bool] = None,
                 https: Optional[bool] = None,
                 job_timeout_millis: Optional[int] = None,
                 request_timeout_millis: Optional[int] = None,
                 static_values: Optional[bool] = None,
                 url_path: Optional[str] = None,
                 use_xhr: Optional[bool] = None):
        PulsarJobConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            http=http,
            https=https,
            job_timeout_millis=job_timeout_millis,
            request_timeout_millis=request_timeout_millis,
            static_values=static_values,
            url_path=url_path,
            use_xhr=use_xhr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[str] = None,
             http: Optional[bool] = None,
             https: Optional[bool] = None,
             job_timeout_millis: Optional[int] = None,
             request_timeout_millis: Optional[int] = None,
             static_values: Optional[bool] = None,
             url_path: Optional[str] = None,
             use_xhr: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if host is not None:
            _setter("host", host)
        if http is not None:
            _setter("http", http)
        if https is not None:
            _setter("https", https)
        if job_timeout_millis is not None:
            _setter("job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            _setter("request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            _setter("static_values", static_values)
        if url_path is not None:
            _setter("url_path", url_path)
        if use_xhr is not None:
            _setter("use_xhr", use_xhr)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http(self) -> Optional[bool]:
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def https(self) -> Optional[bool]:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "job_timeout_millis")

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "request_timeout_millis")

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[bool]:
        return pulumi.get(self, "static_values")

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[str]:
        return pulumi.get(self, "url_path")

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[bool]:
        return pulumi.get(self, "use_xhr")


@pulumi.output_type
class PulsarJobWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PulsarJobWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PulsarJobWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PulsarJobWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: float,
                 name: str,
                 weight: int,
                 maximize: Optional[bool] = None):
        PulsarJobWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value=default_value,
            name=name,
            weight=weight,
            maximize=maximize,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value: float,
             name: str,
             weight: int,
             maximize: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_value", default_value)
        _setter("name", name)
        _setter("weight", weight)
        if maximize is not None:
            _setter("maximize", maximize)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> float:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def maximize(self) -> Optional[bool]:
        return pulumi.get(self, "maximize")


@pulumi.output_type
class RecordAnswer(dict):
    def __init__(__self__, *,
                 answer: Optional[str] = None,
                 meta: Optional[Mapping[str, Any]] = None,
                 region: Optional[str] = None):
        """
        :param str answer: Space delimited string of RDATA fields dependent on the record type.
               
               A:
               
               answer = "1.2.3.4"
               
               CNAME:
               
               answer = "www.example.com"
               
               MX:
               
               answer = "5 mail.example.com"
               
               SRV:
               
               answer = "10 0 2380 node-1.example.com"
               
               SPF:
               
               answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        :param str region: The region (Answer Group really) that this answer
               belongs to. This should be one of the names specified in `regions`. Only a
               single `region` per answer is currently supported. If you want an answer in
               multiple regions, duplicating the answer (including metadata) is the correct
               approach.
               * ` meta` - (Optional) meta is supported at the `answer` level. Meta
               is documented below.
        """
        RecordAnswer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            answer=answer,
            meta=meta,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             answer: Optional[str] = None,
             meta: Optional[Mapping[str, Any]] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if answer is not None:
            _setter("answer", answer)
        if meta is not None:
            _setter("meta", meta)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def answer(self) -> Optional[str]:
        """
        Space delimited string of RDATA fields dependent on the record type.

        A:

        answer = "1.2.3.4"

        CNAME:

        answer = "www.example.com"

        MX:

        answer = "5 mail.example.com"

        SRV:

        answer = "10 0 2380 node-1.example.com"

        SPF:

        answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        """
        return pulumi.get(self, "answer")

    @property
    @pulumi.getter
    def meta(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region (Answer Group really) that this answer
        belongs to. This should be one of the names specified in `regions`. Only a
        single `region` per answer is currently supported. If you want an answer in
        multiple regions, duplicating the answer (including metadata) is the correct
        approach.
        * ` meta` - (Optional) meta is supported at the `answer` level. Meta
        is documented below.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class RecordFilter(dict):
    def __init__(__self__, *,
                 filter: str,
                 config: Optional[Mapping[str, Any]] = None,
                 disabled: Optional[bool] = None):
        """
        :param str filter: The type of filter.
        :param Mapping[str, Any] config: The filters' configuration. Simple key/value pairs
               determined by the filter type.
        :param bool disabled: Determines whether the filter is applied in the
               filter chain.
        """
        RecordFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter=filter,
            config=config,
            disabled=disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter: str,
             config: Optional[Mapping[str, Any]] = None,
             disabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter", filter)
        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        The type of filter.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The filters' configuration. Simple key/value pairs
        determined by the filter type.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Determines whether the filter is applied in the
        filter chain.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class RecordRegion(dict):
    def __init__(__self__, *,
                 name: str,
                 meta: Optional[Mapping[str, Any]] = None):
        """
        :param str name: Name of the region (or Answer Group).
        """
        RecordRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            meta=meta,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             meta: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if meta is not None:
            _setter("meta", meta)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region (or Answer Group).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def meta(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "meta")


@pulumi.output_type
class TeamDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        TeamDnsRecordsAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class TeamDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        TeamDnsRecordsDeny._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class TeamIpWhitelist(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The free form name of the team.
        """
        TeamIpWhitelist._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The free form name of the team.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class UserDnsRecordsAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDnsRecordsAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDnsRecordsAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDnsRecordsAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        UserDnsRecordsAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class UserDnsRecordsDeny(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserDnsRecordsDeny. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserDnsRecordsDeny.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserDnsRecordsDeny.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 include_subdomains: bool,
                 type: str,
                 zone: str):
        UserDnsRecordsDeny._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             include_subdomains: bool,
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> bool:
        return pulumi.get(self, "include_subdomains")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class ZoneSecondary(dict):
    def __init__(__self__, *,
                 ip: str,
                 networks: Optional[Sequence[int]] = None,
                 notify: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param str ip: IPv4 address of the secondary server.
        :param Sequence[int] networks: List of network IDs (`int`) for which the zone
               should be made available. Default is network 0, the primary NSONE Global
               Network. Normally, you should not have to worry about this.
        :param bool notify: Whether we send `NOTIFY` messages to the secondary host
               when the zone changes. Default `false`.
        :param int port: Port of the the secondary server. Default `53`.
        """
        ZoneSecondary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            networks=networks,
            notify=notify,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             networks: Optional[Sequence[int]] = None,
             notify: Optional[bool] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        if networks is not None:
            _setter("networks", networks)
        if notify is not None:
            _setter("notify", notify)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address of the secondary server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[int]]:
        """
        List of network IDs (`int`) for which the zone
        should be made available. Default is network 0, the primary NSONE Global
        Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def notify(self) -> Optional[bool]:
        """
        Whether we send `NOTIFY` messages to the secondary host
        when the zone changes. Default `false`.
        """
        return pulumi.get(self, "notify")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the the secondary server. Default `53`.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetDNSSecDelegationResult(dict):
    def __init__(__self__, *,
                 dnskeys: Sequence['outputs.GetDNSSecDelegationDnskeyResult'],
                 ds: Sequence['outputs.GetDNSSecDelegationDResult'],
                 ttl: int):
        """
        :param Sequence['GetDNSSecDelegationDnskeyArgs'] dnskeys: (Computed) List of Keys. Key is documented below.
        :param Sequence['GetDNSSecDelegationDArgs'] ds: (Computed) List of Keys. Key is documented below.
        :param int ttl: (Computed) TTL for the Keys (int).
        """
        GetDNSSecDelegationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dnskeys=dnskeys,
            ds=ds,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dnskeys: Sequence['outputs.GetDNSSecDelegationDnskeyResult'],
             ds: Sequence['outputs.GetDNSSecDelegationDResult'],
             ttl: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dnskeys", dnskeys)
        _setter("ds", ds)
        _setter("ttl", ttl)

    @property
    @pulumi.getter
    def dnskeys(self) -> Sequence['outputs.GetDNSSecDelegationDnskeyResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "dnskeys")

    @property
    @pulumi.getter
    def ds(self) -> Sequence['outputs.GetDNSSecDelegationDResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "ds")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        (Computed) TTL for the Keys (int).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetDNSSecDelegationDResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 flags: str,
                 protocol: str,
                 public_key: str):
        """
        :param str algorithm: (Computed) Algorithm of the key.
        :param str flags: (Computed) Flags for the key.
        :param str protocol: (Computed) Protocol of the key.
        :param str public_key: (Computed) Public key for the key.
        """
        GetDNSSecDelegationDResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            flags=flags,
            protocol=protocol,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: str,
             flags: str,
             protocol: str,
             public_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("algorithm", algorithm)
        _setter("flags", flags)
        _setter("protocol", protocol)
        _setter("public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetDNSSecDelegationDnskeyResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 flags: str,
                 protocol: str,
                 public_key: str):
        """
        :param str algorithm: (Computed) Algorithm of the key.
        :param str flags: (Computed) Flags for the key.
        :param str protocol: (Computed) Protocol of the key.
        :param str public_key: (Computed) Public key for the key.
        """
        GetDNSSecDelegationDnskeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            flags=flags,
            protocol=protocol,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: str,
             flags: str,
             protocol: str,
             public_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("algorithm", algorithm)
        _setter("flags", flags)
        _setter("protocol", protocol)
        _setter("public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetDNSSecKeyResult(dict):
    def __init__(__self__, *,
                 dnskeys: Sequence['outputs.GetDNSSecKeyDnskeyResult'],
                 ttl: int):
        """
        :param Sequence['GetDNSSecKeyDnskeyArgs'] dnskeys: (Computed) List of Keys. Key is documented below.
        :param int ttl: (Computed) TTL for the Keys (int).
        """
        GetDNSSecKeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dnskeys=dnskeys,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dnskeys: Sequence['outputs.GetDNSSecKeyDnskeyResult'],
             ttl: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dnskeys", dnskeys)
        _setter("ttl", ttl)

    @property
    @pulumi.getter
    def dnskeys(self) -> Sequence['outputs.GetDNSSecKeyDnskeyResult']:
        """
        (Computed) List of Keys. Key is documented below.
        """
        return pulumi.get(self, "dnskeys")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        (Computed) TTL for the Keys (int).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetDNSSecKeyDnskeyResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 flags: str,
                 protocol: str,
                 public_key: str):
        """
        :param str algorithm: (Computed) Algorithm of the key.
        :param str flags: (Computed) Flags for the key.
        :param str protocol: (Computed) Protocol of the key.
        :param str public_key: (Computed) Public key for the key.
        """
        GetDNSSecKeyDnskeyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            flags=flags,
            protocol=protocol,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: str,
             flags: str,
             protocol: str,
             public_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("algorithm", algorithm)
        _setter("flags", flags)
        _setter("protocol", protocol)
        _setter("public_key", public_key)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        (Computed) Algorithm of the key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def flags(self) -> str:
        """
        (Computed) Flags for the key.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (Computed) Protocol of the key.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        (Computed) Public key for the key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetNetworksNetworkResult(dict):
    def __init__(__self__, *,
                 label: str,
                 name: str,
                 network_id: int):
        """
        :param str label: Label associated with the network.
        :param str name: Name of the network.
        :param int network_id: network ID (`int`). Default is network 0, the primary NS1 Managed DNS Network.
        """
        GetNetworksNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            name=name,
            network_id=network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: str,
             name: str,
             network_id: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("label", label)
        _setter("name", name)
        _setter("network_id", network_id)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label associated with the network.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the network.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> int:
        """
        network ID (`int`). Default is network 0, the primary NS1 Managed DNS Network.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class GetRecordAnswerResult(dict):
    def __init__(__self__, *,
                 answer: str,
                 meta: Mapping[str, Any],
                 region: str):
        """
        :param Mapping[str, Any] meta: Map of metadata
        """
        GetRecordAnswerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            answer=answer,
            meta=meta,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             answer: str,
             meta: Mapping[str, Any],
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("answer", answer)
        _setter("meta", meta)
        _setter("region", region)

    @property
    @pulumi.getter
    def answer(self) -> str:
        return pulumi.get(self, "answer")

    @property
    @pulumi.getter
    def meta(self) -> Mapping[str, Any]:
        """
        Map of metadata
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetRecordFilterResult(dict):
    def __init__(__self__, *,
                 config: Mapping[str, Any],
                 disabled: bool,
                 filter: str):
        GetRecordFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            filter=filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Mapping[str, Any],
             disabled: bool,
             filter: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config", config)
        _setter("disabled", disabled)
        _setter("filter", filter)

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, Any]:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")


@pulumi.output_type
class GetRecordRegionResult(dict):
    def __init__(__self__, *,
                 meta: Mapping[str, Any],
                 name: str):
        """
        :param Mapping[str, Any] meta: Map of metadata
        """
        GetRecordRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            meta=meta,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             meta: Mapping[str, Any],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("meta", meta)
        _setter("name", name)

    @property
    @pulumi.getter
    def meta(self) -> Mapping[str, Any]:
        """
        Map of metadata
        """
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetZoneSecondaryResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 networks: Sequence[int],
                 notify: bool,
                 port: int):
        """
        :param str ip: IPv4 address of the secondary server.
        :param Sequence[int] networks: List of network IDs (`int`) for which the zone should be made
               available. Default is network 0, the primary NSONE Global Network.
        :param bool notify: Whether we send `NOTIFY` messages to the secondary host
               when the zone changes. Default `false`.
        :param int port: Port of the the secondary server. Default `53`.
        """
        GetZoneSecondaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            networks=networks,
            notify=notify,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             networks: Sequence[int],
             notify: bool,
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        _setter("networks", networks)
        _setter("notify", notify)
        _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IPv4 address of the secondary server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def networks(self) -> Sequence[int]:
        """
        List of network IDs (`int`) for which the zone should be made
        available. Default is network 0, the primary NSONE Global Network.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def notify(self) -> bool:
        """
        Whether we send `NOTIFY` messages to the secondary host
        when the zone changes. Default `false`.
        """
        return pulumi.get(self, "notify")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port of the the secondary server. Default `53`.
        """
        return pulumi.get(self, "port")


