# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'APIKeyDnsRecordsAllowArgs',
    'APIKeyDnsRecordsDenyArgs',
    'ApplicationDefaultConfigArgs',
    'MonitoringJobRuleArgs',
    'NotifyListNotificationArgs',
    'PulsarJobBlendMetricWeightsArgs',
    'PulsarJobConfigArgs',
    'PulsarJobWeightArgs',
    'RecordAnswerArgs',
    'RecordFilterArgs',
    'RecordRegionArgs',
    'TeamDnsRecordsAllowArgs',
    'TeamDnsRecordsDenyArgs',
    'TeamIpWhitelistArgs',
    'UserDnsRecordsAllowArgs',
    'UserDnsRecordsDenyArgs',
    'ZoneSecondaryArgs',
]

@pulumi.input_type
class APIKeyDnsRecordsAllowArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        APIKeyDnsRecordsAllowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class APIKeyDnsRecordsDenyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        APIKeyDnsRecordsDenyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class ApplicationDefaultConfigArgs:
    def __init__(__self__, *,
                 http: pulumi.Input[bool],
                 https: Optional[pulumi.Input[bool]] = None,
                 job_timeout_millis: Optional[pulumi.Input[int]] = None,
                 request_timeout_millis: Optional[pulumi.Input[int]] = None,
                 static_values: Optional[pulumi.Input[bool]] = None,
                 use_xhr: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] http: Indicates whether or not to use HTTP in measurements.
        :param pulumi.Input[bool] https: Indicates whether or not to use HTTPS in measurements.
        :param pulumi.Input[int] job_timeout_millis: Maximum timeout per job
               0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        :param pulumi.Input[int] request_timeout_millis: Maximum timeout per request.
        :param pulumi.Input[bool] static_values: Indicates whether or not to skip aggregation for this job's measurements
        :param pulumi.Input[bool] use_xhr: Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        ApplicationDefaultConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http=http,
            https=https,
            job_timeout_millis=job_timeout_millis,
            request_timeout_millis=request_timeout_millis,
            static_values=static_values,
            use_xhr=use_xhr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http: pulumi.Input[bool],
             https: Optional[pulumi.Input[bool]] = None,
             job_timeout_millis: Optional[pulumi.Input[int]] = None,
             request_timeout_millis: Optional[pulumi.Input[int]] = None,
             static_values: Optional[pulumi.Input[bool]] = None,
             use_xhr: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("http", http)
        if https is not None:
            _setter("https", https)
        if job_timeout_millis is not None:
            _setter("job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            _setter("request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            _setter("static_values", static_values)
        if use_xhr is not None:
            _setter("use_xhr", use_xhr)

    @property
    @pulumi.getter
    def http(self) -> pulumi.Input[bool]:
        """
        Indicates whether or not to use HTTP in measurements.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: pulumi.Input[bool]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not to use HTTPS in measurements.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum timeout per job
        0, the primary NSONE Global Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "job_timeout_millis")

    @job_timeout_millis.setter
    def job_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_timeout_millis", value)

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum timeout per request.
        """
        return pulumi.get(self, "request_timeout_millis")

    @request_timeout_millis.setter
    def request_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout_millis", value)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not to skip aggregation for this job's measurements
        """
        return pulumi.get(self, "static_values")

    @static_values.setter
    def static_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static_values", value)

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use XMLHttpRequest (XHR) when taking measurements.
        """
        return pulumi.get(self, "use_xhr")

    @use_xhr.setter
    def use_xhr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_xhr", value)


@pulumi.input_type
class MonitoringJobRuleArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        MonitoringJobRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison=comparison,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison: pulumi.Input[str],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparison", comparison)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NotifyListNotificationArgs:
    def __init__(__self__, *,
                 config: pulumi.Input[Mapping[str, Any]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, Any]] config: Configuration details for the given notifier type.
        :param pulumi.Input[str] type: The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        NotifyListNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: pulumi.Input[Mapping[str, Any]],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config", config)
        _setter("type", type)

    @property
    @pulumi.getter
    def config(self) -> pulumi.Input[Mapping[str, Any]]:
        """
        Configuration details for the given notifier type.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of notifier. Available notifiers are indicated in /notifytypes endpoint.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PulsarJobBlendMetricWeightsArgs:
    def __init__(__self__, *,
                 timestamp: pulumi.Input[int]):
        PulsarJobBlendMetricWeightsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timestamp: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timestamp", timestamp)

    @property
    @pulumi.getter
    def timestamp(self) -> pulumi.Input[int]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: pulumi.Input[int]):
        pulumi.set(self, "timestamp", value)


@pulumi.input_type
class PulsarJobConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 http: Optional[pulumi.Input[bool]] = None,
                 https: Optional[pulumi.Input[bool]] = None,
                 job_timeout_millis: Optional[pulumi.Input[int]] = None,
                 request_timeout_millis: Optional[pulumi.Input[int]] = None,
                 static_values: Optional[pulumi.Input[bool]] = None,
                 url_path: Optional[pulumi.Input[str]] = None,
                 use_xhr: Optional[pulumi.Input[bool]] = None):
        PulsarJobConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            http=http,
            https=https,
            job_timeout_millis=job_timeout_millis,
            request_timeout_millis=request_timeout_millis,
            static_values=static_values,
            url_path=url_path,
            use_xhr=use_xhr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[pulumi.Input[str]] = None,
             http: Optional[pulumi.Input[bool]] = None,
             https: Optional[pulumi.Input[bool]] = None,
             job_timeout_millis: Optional[pulumi.Input[int]] = None,
             request_timeout_millis: Optional[pulumi.Input[int]] = None,
             static_values: Optional[pulumi.Input[bool]] = None,
             url_path: Optional[pulumi.Input[str]] = None,
             use_xhr: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if host is not None:
            _setter("host", host)
        if http is not None:
            _setter("http", http)
        if https is not None:
            _setter("https", https)
        if job_timeout_millis is not None:
            _setter("job_timeout_millis", job_timeout_millis)
        if request_timeout_millis is not None:
            _setter("request_timeout_millis", request_timeout_millis)
        if static_values is not None:
            _setter("static_values", static_values)
        if url_path is not None:
            _setter("url_path", url_path)
        if use_xhr is not None:
            _setter("use_xhr", use_xhr)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter(name="jobTimeoutMillis")
    def job_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "job_timeout_millis")

    @job_timeout_millis.setter
    def job_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_timeout_millis", value)

    @property
    @pulumi.getter(name="requestTimeoutMillis")
    def request_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "request_timeout_millis")

    @request_timeout_millis.setter
    def request_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout_millis", value)

    @property
    @pulumi.getter(name="staticValues")
    def static_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "static_values")

    @static_values.setter
    def static_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static_values", value)

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_path", value)

    @property
    @pulumi.getter(name="useXhr")
    def use_xhr(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_xhr")

    @use_xhr.setter
    def use_xhr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_xhr", value)


@pulumi.input_type
class PulsarJobWeightArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[float],
                 name: pulumi.Input[str],
                 weight: pulumi.Input[int],
                 maximize: Optional[pulumi.Input[bool]] = None):
        PulsarJobWeightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value=default_value,
            name=name,
            weight=weight,
            maximize=maximize,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value: pulumi.Input[float],
             name: pulumi.Input[str],
             weight: pulumi.Input[int],
             maximize: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_value", default_value)
        _setter("name", name)
        _setter("weight", weight)
        if maximize is not None:
            _setter("maximize", maximize)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def maximize(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "maximize")

    @maximize.setter
    def maximize(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maximize", value)


@pulumi.input_type
class RecordAnswerArgs:
    def __init__(__self__, *,
                 answer: Optional[pulumi.Input[str]] = None,
                 meta: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] answer: Space delimited string of RDATA fields dependent on the record type.
               
               A:
               
               answer = "1.2.3.4"
               
               CNAME:
               
               answer = "www.example.com"
               
               MX:
               
               answer = "5 mail.example.com"
               
               SRV:
               
               answer = "10 0 2380 node-1.example.com"
               
               SPF:
               
               answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        :param pulumi.Input[str] region: The region (Answer Group really) that this answer
               belongs to. This should be one of the names specified in `regions`. Only a
               single `region` per answer is currently supported. If you want an answer in
               multiple regions, duplicating the answer (including metadata) is the correct
               approach.
               * ` meta` - (Optional) meta is supported at the `answer` level. Meta
               is documented below.
        """
        RecordAnswerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            answer=answer,
            meta=meta,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             answer: Optional[pulumi.Input[str]] = None,
             meta: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if answer is not None:
            _setter("answer", answer)
        if meta is not None:
            _setter("meta", meta)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def answer(self) -> Optional[pulumi.Input[str]]:
        """
        Space delimited string of RDATA fields dependent on the record type.

        A:

        answer = "1.2.3.4"

        CNAME:

        answer = "www.example.com"

        MX:

        answer = "5 mail.example.com"

        SRV:

        answer = "10 0 2380 node-1.example.com"

        SPF:

        answer = "v=DKIM1; k=rsa; p=XXXXXXXX"
        """
        return pulumi.get(self, "answer")

    @answer.setter
    def answer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "answer", value)

    @property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "meta", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region (Answer Group really) that this answer
        belongs to. This should be one of the names specified in `regions`. Only a
        single `region` per answer is currently supported. If you want an answer in
        multiple regions, duplicating the answer (including metadata) is the correct
        approach.
        * ` meta` - (Optional) meta is supported at the `answer` level. Meta
        is documented below.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class RecordFilterArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filter: The type of filter.
        :param pulumi.Input[Mapping[str, Any]] config: The filters' configuration. Simple key/value pairs
               determined by the filter type.
        :param pulumi.Input[bool] disabled: Determines whether the filter is applied in the
               filter chain.
        """
        RecordFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter=filter,
            config=config,
            disabled=disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter: pulumi.Input[str],
             config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter", filter)
        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[str]:
        """
        The type of filter.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The filters' configuration. Simple key/value pairs
        determined by the filter type.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the filter is applied in the
        filter chain.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


@pulumi.input_type
class RecordRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 meta: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] name: Name of the region (or Answer Group).
        """
        RecordRegionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            meta=meta,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             meta: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if meta is not None:
            _setter("meta", meta)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the region (or Answer Group).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "meta", value)


@pulumi.input_type
class TeamDnsRecordsAllowArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        TeamDnsRecordsAllowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class TeamDnsRecordsDenyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        TeamDnsRecordsDenyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class TeamIpWhitelistArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The free form name of the team.
        """
        TeamIpWhitelistArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The free form name of the team.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class UserDnsRecordsAllowArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        UserDnsRecordsAllowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class UserDnsRecordsDenyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 include_subdomains: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str]):
        UserDnsRecordsDenyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            include_subdomains=include_subdomains,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             include_subdomains: pulumi.Input[bool],
             type: pulumi.Input[str],
             zone: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("include_subdomains", include_subdomains)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class ZoneSecondaryArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 notify: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ip: IPv4 address of the secondary server.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] networks: List of network IDs (`int`) for which the zone
               should be made available. Default is network 0, the primary NSONE Global
               Network. Normally, you should not have to worry about this.
        :param pulumi.Input[bool] notify: Whether we send `NOTIFY` messages to the secondary host
               when the zone changes. Default `false`.
        :param pulumi.Input[int] port: Port of the the secondary server. Default `53`.
        """
        ZoneSecondaryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            networks=networks,
            notify=notify,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             networks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             notify: Optional[pulumi.Input[bool]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        if networks is not None:
            _setter("networks", networks)
        if notify is not None:
            _setter("notify", notify)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IPv4 address of the secondary server.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of network IDs (`int`) for which the zone
        should be made available. Default is network 0, the primary NSONE Global
        Network. Normally, you should not have to worry about this.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def notify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether we send `NOTIFY` messages to the secondary host
        when the zone changes. Default `false`.
        """
        return pulumi.get(self, "notify")

    @notify.setter
    def notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notify", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the the secondary server. Default `53`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


